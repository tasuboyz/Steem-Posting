<html><head><base href="">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Market Analysis</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .analysis-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        .header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .header img {
            width: 50px;
            height: 50px;
            margin-right: 15px;
        }
        .timestamp {
            color: #666;
            font-size: 0.9em;
        }
        .chart-container {
            height: 400px;
            margin: 20px 0;
            padding: 20px
        }
        .fear-greed-index {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 150px;
            margin: 20px 0;
            position: relative;
            padding: 50px
        }
        .section {
            margin: 30px 0;
        }
        .section-title {
            font-size: 1.5em;
            color: #333;
            margin-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
        }
        .comments-section {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
        }
        .download-btn {
            background: none;
            border: none;
            color: #4CAF50;
            padding: 5px;
            cursor: pointer;
            font-size: 18px;
            transition: color 0.3s;
        }
        .download-btn:hover {
            color: #45a049;
        }
        .download-container {
            position: absolute;
            right: 10px;
            top: 10px;
            z-index: 100;
        }
        .chart-wrapper {
            position: relative;
        }
    </style>

</head>
<body>
    <div class="analysis-container">
        <div class="header">
            <svg width="50" height="50" viewBox="0 0 50 50">
                <circle cx="25" cy="25" r="25" fill="#F7931A"/>
                <text x="25" y="25" font-size="35" text-anchor="middle" dy=".3em" fill="white">₿</text>
            </svg>
            <div>
                <h1>Bitcoin Market Analysis</h1>
                <div class="timestamp">Pubblicato il: <span id="currentDate"></span></div>
            </div>
        </div>

        <div class="chart-wrapper">
            <div class="download-container">
                <button id="downloadBTCChart" class="download-btn" title="Scarica Grafico BTC">
                    <i class="fas fa-download"></i>
                </button>
            </div>
            <div id="btcChart" class="chart-container"></div>
        </div>

        <div class="chart-wrapper">
            <div class="download-container">
                <button id="downloadVolumeChart" class="download-btn" title="Scarica Grafico Volume">
                    <i class="fas fa-download"></i>
                </button>
            </div>
            <div id="volumeChart" class="chart-container" style="height: 200px;"></div>
        </div>

        <div class="chart-wrapper">
            <div class="download-container">
                <button id="downloadFearGreedChart" class="download-btn" title="Scarica Indice Paura & Avidità">
                    <i class="fas fa-download"></i>
                </button>
            </div>
            <div class="fear-greed-index" id="fearGreedGauge"></div>
        </div>

        <div class="section">
            <h2 class="section-title">Analisi dei Dati</h2>
            <p>Prezzo Bitcoin Attuale: <span id="currentPrice"></span></p>
            <p>Volume 24h: <span id="volume"></span></p>
            <p>Indice Paura & Avidità: <span id="fearGreedValue"></span></p>
        </div>

        <div class="section">
            <h2 class="section-title">Interpretazione Tecnica</h2>
            <p>Basato sull'analisi del Cloud Ichimoku:</p>
            <ul id="technicalAnalysis">
            </ul>
        </div>

        <div class="section">
            <h2 class="section-title">Considerazioni Personali</h2>
            <p id="personalConsiderations"></p>
        </div>

        <div class="comments-section">
            <h3>Domanda per i Lettori</h3>
            <div id="readerQuestion"></div>
        </div>
    </div>

    <script>
        document.getElementById('currentDate').textContent = new Date().toLocaleDateString();

        function calculateKijunSen(data, period = 26) {
            const high = Math.max(...data.slice(-period).map(d => d.high));
            const low = Math.min(...data.slice(-period).map(d => d.low));
            return (high + low) / 2;
        }

        function calculateVolatility(data, period = 30) {
            const returns = data.slice(-period).map((d, i, arr) => {
                if (i === 0) return 0;
                return (d.close - arr[i - 1].close) / arr[i - 1].close;
            });
            const mean = returns.reduce((a, b) => a + b) / (returns.length - 1);
            const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (returns.length - 1);
            return Math.sqrt(variance) * 100; 
        }

        function calculateKeySupport(data) {
            const recentLows = data.slice(-30).map(d => d.low);
            return Math.min(...recentLows);
        }

        async function updatePersonalConsiderations() {
            const binanceData = await fetchBinanceData();
            const lastCandle = binanceData[binanceData.length - 1];
            const priceChangePercentage = ((lastCandle.close - lastCandle.open) / lastCandle.open) * 100;
            const fearGreedIndex = await fetchFearAndGreedData();
            const rsiValue = calculateRSI(binanceData).slice(-1)[0].value;
            const macdValue = calculateMACD(binanceData).slice(-1)[0].histogram;

            const kijunSen = calculateKijunSen(binanceData);
            const bitcoinVolatility = calculateVolatility(binanceData);
            const keySupport = calculateKeySupport(binanceData);

            let considerations = "Attualmente, il prezzo di Bitcoin si attesta a $" + lastCandle.close.toFixed(2) + 
                                ", con una variazione del " + priceChangePercentage.toFixed(2) + "% rispetto all'apertura. ";

            if (fearGreedIndex < 20) {
                considerations += "Questo è un momento di 'paura estrema', il che storicamente suggerisce che potrebbe essere un buon punto di accumulo per gli investitori a lungo termine. ";
            } else if (fearGreedIndex > 80) {
                considerations += "Con un indice di 'avidità estrema', potremmo trovarci in una fase di correzione imminente, quindi è importante essere cauti. ";
            } else {
                considerations += "L'indice di paura e avidità si attesta a " + fearGreedIndex + ", indicando una situazione di mercato più equilibrata. ";
            }

            if (rsiValue > 70) {
                considerations += "Attualmente, l'RSI è a " + rsiValue.toFixed(2) + ", suggerendo che Bitcoin è in una condizione di 'ipercomprato', il che potrebbe indicare una correzione a breve termine. ";
            } else if (rsiValue < 30) {
                considerations += "Con un RSI di " + rsiValue.toFixed(2) + ", Bitcoin è considerato 'ipervenduto', suggerendo che potrebbe esserci spazio per un rimbalzo. ";
            } else {
                considerations += "L'RSI attuale è di " + rsiValue.toFixed(2) + ", il che indica una situazione di mercato neutra. ";
            }

            if (macdValue > 0) {
                considerations += "Inoltre, l'analisi MACD mostra un valore positivo, suggerendo una momentum rialzista. ";
            } else {
                considerations += "Il valore negativo del MACD indica una momentum ribassista, il che richiede attenzione. ";
            }

            considerations += "<br><br>Attualmente, il prezzo di Bitcoin si attesta a $" + lastCandle.close.toFixed(4) + 
                             ", al di sotto del Kijun-sen di $" + kijunSen.toFixed(4) + ". Questo suggerisce una potenziale fase ribassista. " +
                             "Con una volatilità del " + bitcoinVolatility.toFixed(2) + "%, il rischio di movimenti verso il basso rimane elevato. " +
                             "È fondamentale prestare attenzione al supporto chiave a $" + keySupport.toFixed(4) + " e valutare eventuali segnali di inversione. ";

            considerations += "Per ora, è consigliabile essere cauti e osservare se il prezzo riesce a trovare supporto o se continuerà a scendere verso livelli inferiori.";

            document.getElementById("personalConsiderations").innerHTML = considerations
        }

        async function fetchBinanceData() {
            try {
                const endTime = new Date();
                const startTime = new Date(endTime);
                startTime.setMonth(startTime.getMonth() - 3);
                const startTimestamp = startTime.getTime();
                
                const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=4h&startTime=${startTimestamp}`;
                const response = await fetch(url);
                const data = await response.json();
                
                return data.map(d => ({
                    time: d[0] / 1000,
                    open: parseFloat(d[1]),
                    high: parseFloat(d[2]),
                    low: parseFloat(d[3]),
                    close: parseFloat(d[4]),
                    volume: parseFloat(d[5])
                }));
            } catch (error) {
                console.error('Error fetching Binance data:', error);
                return null;
            }
        }

        async function fetchCoinGeckoVolume() {
            try {
                const endTime = new Date();
                const startTime = new Date(endTime);
                startTime.setMonth(startTime.getMonth() - 3);
                
                const url = `https://api.coingecko.com/api/v3/coins/bitcoin/market_chart/range?vs_currency=usd&from=${Math.floor(startTime.getTime()/1000)}&to=${Math.floor(endTime.getTime()/1000)}`;
                const response = await fetch(url);
                const data = await response.json();
                
                return data.total_volumes.map(item => ({
                    time: item[0] / 1000,
                    value: item[1],
                    color: '#26a69a'
                }));
            } catch (error) {
                console.error('Error fetching CoinGecko volume data:', error);
                return null;
            }
        }

        function calculateIchimoku(data) {
            const conversion = 9;
            const base = 26;
            const spanB = 52;
            const displacement = 26;

            return data.map((candle, index) => {
                if (index < spanB) return null;

                const conversionHigh = Math.max(...data.slice(index - conversion, index).map(d => d.high));
                const conversionLow = Math.min(...data.slice(index - conversion, index).map(d => d.low));
                const tenkanSen = (conversionHigh + conversionLow) / 2;

                const baseHigh = Math.max(...data.slice(index - base, index).map(d => d.high));
                const baseLow = Math.min(...data.slice(index - base, index).map(d => d.low));
                const kijunSen = (baseHigh + baseLow) / 2;

                const senkouSpanA = (tenkanSen + kijunSen) / 2;

                const spanBHigh = Math.max(...data.slice(index - spanB, index).map(d => d.high));
                const spanBLow = Math.min(...data.slice(index - spanB, index).map(d => d.low));
                const senkouSpanB = (spanBHigh + spanBLow) / 2;

                return {
                    time: candle.time,
                    tenkanSen,
                    kijunSen,
                    senkouSpanA,
                    senkouSpanB
                };
            }).filter(d => d !== null);
        }

        function calculateRSI(data, period = 14) {
            let gains = [], losses = [];
            
            for(let i = 1; i < data.length; i++) {
                const change = data[i].close - data[i-1].close;
                gains.push(change >= 0 ? change : 0);
                losses.push(change < 0 ? Math.abs(change) : 0);
            }
            
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b) / period;
            
            let rsiData = [];
            
            for(let i = period; i < data.length; i++) {
                avgGain = ((avgGain * (period - 1)) + (gains[i-1] || 0)) / period;
                avgLoss = ((avgLoss * (period - 1)) + (losses[i-1] || 0)) / period;
                
                const rs = avgGain / avgLoss;
                const rsi = 100 - (100 / (1 + rs));
                
                rsiData.push({
                    time: data[i].time,
                    value: rsi
                });
            }
            
            return rsiData;
        }

        function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            function ema(data, period) {
                const k = 2 / (period + 1);
                let emaData = [data[0]];
                
                for(let i = 1; i < data.length; i++) {
                    emaData[i] = data[i] * k + emaData[i-1] * (1-k);
                }
                return emaData;
            }
            
            const closes = data.map(d => d.close);
            const fastEMA = ema(closes, fastPeriod);
            const slowEMA = ema(closes, slowPeriod);
            
            const macdLine = fastEMA.map((fast, i) => fast - slowEMA[i]);
            const signalLine = ema(macdLine, signalPeriod);
            
            return data.map((d, i) => ({
                time: d.time,
                macd: macdLine[i],
                signal: signalLine[i],
                histogram: macdLine[i] - signalLine[i]
            }));
        }

        async function fetchFearAndGreedData() {
            try {
                const response = await fetch('https://api.alternative.me/fng/');
                const data = await response.json();
                return data.data[0].value;
            } catch (error) {
                console.error('Error fetching Fear & Greed data:', error);
                return null;
            }
        }

        async function createCharts() {
            const [binanceData, fearGreedValue, volumeData] = await Promise.all([
                fetchBinanceData(),
                fetchFearAndGreedData(),
                fetchCoinGeckoVolume()
            ]);
            
            if (!binanceData || !volumeData) return;

            const ichimokuData = calculateIchimoku(binanceData);
            const rsiData = calculateRSI(binanceData);
            const macdData = calculateMACD(binanceData);

            const chart = LightweightCharts.createChart(document.getElementById('btcChart'), {
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                grid: {
                    vertLines: { color: 'rgba(197, 203, 206, 0.5)' },
                    horzLines: { color: 'rgba(197, 203, 206, 0.5)' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: 'rgba(197, 203, 206, 1)',
                    autoScale: true,
                },
                timeScale: {
                    borderColor: 'rgba(197, 203, 206, 1)',
                    timeVisible: true,
                    secondsVisible: false
                },
            });

            const candlestickSeries = chart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350'
            });
            candlestickSeries.setData(binanceData);

            const tenkanSen = chart.addLineSeries({ color: '#0000FF', lineWidth: 1 });
            const kijunSen = chart.addLineSeries({ color: '#FF0000', lineWidth: 1 });
            const senkouSpanA = chart.addLineSeries({ color: '#00FF00', lineWidth: 1 });
            const senkouSpanB = chart.addLineSeries({ color: '#FF0000', lineWidth: 1 });

            tenkanSen.setData(ichimokuData.map(d => ({ time: d.time, value: d.tenkanSen })));
            kijunSen.setData(ichimokuData.map(d => ({ time: d.time, value: d.kijunSen })));
            senkouSpanA.setData(ichimokuData.map(d => ({ time: d.time, value: d.senkouSpanA })));
            senkouSpanB.setData(ichimokuData.map(d => ({ time: d.time, value: d.senkouSpanB })));

            const volumeChart = LightweightCharts.createChart(document.getElementById('volumeChart'), {
                height: 200,
                layout: {
                    backgroundColor: '#ffffff',
                    textColor: '#333',
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: false
                },
            });

            const volumeSeries = volumeChart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: '',
            });

            volumeSeries.setData(volumeData);

            chart.timeScale().fitContent();
            volumeChart.timeScale().fitContent();

            const lastCandle = binanceData[binanceData.length - 1];
            document.getElementById('currentPrice').textContent = `$${lastCandle.close.toFixed(2)}`;
            const lastVolume = volumeData[volumeData.length - 1];
            document.getElementById('volume').textContent = `$${(lastVolume.value/1000000).toFixed(2)}M`;

            if (fearGreedValue) {
                createFearGreedGauge(parseInt(fearGreedValue));
            }

            updateTechnicalAnalysis(
                ichimokuData[ichimokuData.length - 1], 
                lastCandle,
                rsiData,
                macdData
            );
        }

        function updateTechnicalAnalysis(ichimoku, price, rsiData, macdData) {
            const analysis = document.getElementById('technicalAnalysis');
            const items = [];
            
            if (price.close > ichimoku.senkouSpanA && price.close > ichimoku.senkouSpanB) {
                items.push("🟢 Forte Rialzo: Il prezzo è sopra il Cloud Ichimoku");
            } else if (price.close < ichimoku.senkouSpanA && price.close < ichimoku.senkouSpanB) {
                items.push("🔴 Forte Ribasso: Il prezzo è sotto il Cloud Ichimoku");
            } else {
                items.push("🟡 Consolidamento: Il prezzo è all'interno del Cloud Ichimoku");
            }

            const currentRSI = rsiData[rsiData.length - 1].value;
            if (currentRSI > 70) {
                items.push(`🔴 Sopravvalutato: RSI a ${currentRSI.toFixed(2)}`);
            } else if (currentRSI < 30) {
                items.push(`🟢 Sottovalutato: RSI a ${currentRSI.toFixed(2)}`);
            } else {
                items.push(`⚪ RSI Neutro: ${currentRSI.toFixed(2)}`);
            }

            const latestMACD = macdData[macdData.length - 1];
            if (latestMACD.histogram > 0 && latestMACD.histogram > macdData[macdData.length - 2].histogram) {
                items.push("🟢 MACD: Momentum rialzista crescente");
            } else if (latestMACD.histogram < 0 && latestMACD.histogram < macdData[macdData.length - 2].histogram) {
                items.push("🔴 MACD: Momentum ribassista crescente");
            } else {
                items.push("🟡 MACD: Momentum in transizione");
            }

            let bullishSignals = 0;
            let bearishSignals = 0;
            
            if (price.close > ichimoku.senkouSpanA) bullishSignals++;
            if (ichimoku.tenkanSen > ichimoku.kijunSen) bullishSignals++;
            if (currentRSI > 50) bullishSignals++;
            if (latestMACD.histogram > 0) bullishSignals++;
            
            if (price.close < ichimoku.senkouSpanA) bearishSignals++;
            if (ichimoku.tenkanSen < ichimoku.kijunSen) bearishSignals++;
            if (currentRSI < 50) bearishSignals++;
            if (latestMACD.histogram < 0) bearishSignals++;
            
            items.push(`📊 Trend Generale: ${bullishSignals > bearishSignals ? '🟢 Rialzista' : bearishSignals > bullishSignals ? '🔴 Ribassista' : '🟡 Neutro'} (${bullishSignals} vs ${bearishSignals} segnali)`);

            analysis.innerHTML = items.map(item => `<li>${item}</li>`).join('');
        }

        function createFearGreedGauge(value) {
            const data = [{
                type: "indicator",
                mode: "gauge+number",
                value: value,
                title: { text: "Indice Paura & Avidità" },
                gauge: {
                    axis: { range: [0, 100] },
                    bar: { color: "darkblue" },
                    bgcolor: "white",
                    borderwidth: 2,
                    bordercolor: "gray",
                    steps: [
                        { range: [0, 20], color: "red" },
                        { range: [20, 40], color: "orange" },
                        { range: [40, 60], color: "yellow" },
                        { range: [60, 80], color: "lightgreen" },
                        { range: [80, 100], color: "green" }
                    ],
                }
            }];

            const layout = {
                width: 400,
                height: 250,
                margin: { t: 25, r: 25, l: 25, b: 25 },
            };

            Plotly.newPlot('fearGreedGauge', data, layout);
            document.getElementById('fearGreedValue').textContent = `${value} - ${getFearGreedText(value)}`;
        }

        function getFearGreedText(value) {
            if (value <= 20) return "Paura Estrema";
            if (value <= 40) return "Paura";
            if (value <= 60) return "Neutrale";
            if (value <= 80) return "Avidità";
            return "Avidità Estrema";
        }

        function generateDynamicQuestion() {
            const questions = [
                {
                    condition: (fearGreedValue) => fearGreedValue < 30,
                    text: "Con l'indice di Paura & Avidità che mostra estrema paura, pensate che questo sia un buon momento per accumulare? Quale target di prezzo vi aspettate per fine 2024?"
                },
                {
                    condition: (fearGreedValue) => fearGreedValue > 70,
                    text: "L'indice di Paura & Avidità mostra estrema avidità nel mercato. Credete sia il momento di prendere profitto? Quale correzione vi aspettate?"
                },
                {
                    condition: () => true,
                    text: "Considerando l'attuale struttura del mercato e l'avvicinarsi dell'halving di Bitcoin, quale target di prezzo vi aspettate per fine 2024? Condividete la vostra analisi e le vostre motivazioni nei commenti."
                }
            ];

            fetchFearAndGreedData().then(fearGreedValue => {
                const question = questions.find(q => q.condition(fearGreedValue));
                document.getElementById('readerQuestion').innerHTML = `<p>${question.text}</p>`;
            });
        }

        function downloadChart(chartElement, filename) {
            html2canvas(chartElement).then(canvas => {
                const link = document.createElement('a');
                link.download = filename;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        }

        createCharts().then(() => {
            generateDynamicQuestion();
        });
        updatePersonalConsiderations();

        document.getElementById('downloadBTCChart').addEventListener('click', () => {
            downloadChart(document.getElementById('btcChart'), 'bitcoin-chart.png');
        });

        document.getElementById('downloadVolumeChart').addEventListener('click', () => {
            downloadChart(document.getElementById('volumeChart'), 'volume-chart.png');
        });

        document.getElementById('downloadFearGreedChart').addEventListener('click', () => {
            downloadChart(document.getElementById('fearGreedGauge'), 'fear-greed-index.png');
        });
    </script>
</body>
</html>